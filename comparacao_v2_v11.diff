diff --git a/dynamic_sampler_v2.R b/dynamic_sampler_v11.R
index 20609a0..38bbe95 100644
--- a/dynamic_sampler_v2.R
+++ b/dynamic_sampler_v11.R
@@ -1,74 +1,82 @@
-if(!require(nimble)){ install.packages("nimble"); require(nimble)}
 dynamic_sampler <- nimbleFunction(
-  contains = sampler_BASE,  # Inherit from sampler_BASE
-  
+  contains = sampler_BASE,
   setup = function(model, mvSaved, target, control) {
-    # Access model parameters and data, storing them in the scope of the nimbleFunction
-    epsilon <- model$epsilon   # Effect of covariates on the model
-    E <- modelConstants$E      # Constant values for each region and time
-    beta_values <- model$beta         # Regression coefficients
-    Y <- model$Y               # Observed counts
-    a0 <- modelConstants$a0      # Initial value for parameter a
-    b0 <- modelConstants$b0      # Initial value for parameter b
-    w <- modelConstants$w        # Weighting factor
-    x <- modelConstants$x
-    n_regions <- modelConstants$n_regions  # Number of regions
-    n_times <- modelConstants$n_times      # Number of time points
+    ## checagens de controle
+    if(is.null(control$n_regions)) stop("n_regions não definido no controle")
+    if(is.null(control$n_times))   stop("n_times não definido no controle")
+    if(is.null(control$dbeta))     stop("dbeta não definido no controle")
+    if(is.null(control$w))         stop("w não definido no controle")
+    if(is.null(control$a0))        stop("a0 não definido no controle")
+    if(is.null(control$b0))        stop("b0 não definido no controle")
+    n_regions <- as.integer(control$n_regions)[1]
+    n_times   <- as.integer(control$n_times)[1]
+    dbeta     <- as.integer(control$dbeta)[1]
+    w         <- control$w
+    a0        <- constants$a0
+    b0        <- constants$b0
+    ## buffers 2D via nimMatrix
+    att_buf <- nimMatrix(init = 0, nrow = n_regions, ncol = n_times)
+    btt_buf <- nimMatrix(init = 0, nrow = n_regions, ncol = n_times)
+    at_buf  <- nimMatrix(init = 0, nrow = n_regions, ncol = n_times + 1)
+    bt_buf  <- nimMatrix(init = 0, nrow = n_regions, ncol = n_times + 1)
+    ## nós dependentes do target
+    calcNodes <- model$getDependencies(target)
+    ## tudo que o run() precisa tem que ser devolvido aqui
+    setupOutputs(
+      
+        n_regions = n_regions,
+        n_times   = n_times,
+        dbeta     = dbeta,
+        w         = w,
+        a0        = a0,
+        b0        = b0,
+        att_buf   = att_buf,
+        btt_buf   = btt_buf,
+        at_buf    = at_buf,
+        bt_buf    = bt_buf,
+        calcNodes = calcNodes
+      
+    )
   },
-  
   run = function() {
-    cat("Running dynamic sampler for lambda...\n")
-    # Initialize matrices LOCALLY using <-
-    a <- matrix(0, n_regions, n_times)
-    b <- matrix(0, n_regions, n_times)
-    g_b <- matrix(0, n_regions, n_times)
-    lambda <- matrix(0, n_regions, n_times)
-    sum_y <- matrix(0, n_regions, n_times)
-    sum_g_b <- matrix(0, n_regions, n_times)
-    
-    # Initialize time 1 properly
-   
-    for (r in 1:n_regions) {
-      a[r, 1] <- a0
-      b[r, 1] <- b0
-      g_b[r, 1] <- E[r, 1] * epsilon[r, 1] * exp(inprod(beta_values, x[r, 1, ]))
-      sum_g_b[r, 1] <- g_b[r, 1]
-      sum_y[r, 1] <- Y[r, 1]
-      lambda[r, 1] <- rgamma(1, shape = a[r, 1], scale = 1 / b[r, 1])
-    }
-    
-    # Forward loop (t >= 2)
-    for (t in 2:n_times) {
-      for (r in 1:n_regions) {
-        sum_y[r, t] <- sum_y[r, t-1] + Y[r, t]  # Recursive cumulative sum
-        model$a[r, t] <<- w * a[r, t-1] + sum_y[r, t]  # Use <- for assignment
-      }
-      for (r in 1:n_regions) {
-        g_b[r, t] <- E[r, t] * epsilon[r, t] * exp(inprod(beta_values, x[r, t, ]))
-        sum_g_b[r, t] <- sum_g_b[r, t-1] + g_b[r, t]  # Recursive cumulative
-        model$b[r, t] <<- w * b[r, t-1] + sum_g_b[r, t]  # Use <- for assignment
+    declare(i,  integer(0))
+    declare(t,  integer(0))
+    declare(tt, integer(0))
+    declare(k,  integer(0))
+    model$calculate(nodes = "epsilon")
+    for(i in 1:n_regions) {
+      at_buf[i, 1] <<- a0
+      bt_buf[i, 1] <<- b0
+      prod_val <- 0
+      for(k in 1:dbeta) {
+        prod_val <- prod_val + model$x[i, 1, k] * model$beta[k]
       }
-      for (r in 1:n_regions) {
-        lambda[r, t] <- rgamma(1, shape = a[r, t], scale = 1 / b[r, t])  # rgamma not ~
+      for(t in 2:(n_times + 1)) {
+        att_buf[i, t-1] <<- w * at_buf[i, t-1]
+        btt_buf[i, t-1] <<- w * bt_buf[i, t-1]/(model$epsilon[i] * model$E[i, t-1] * exp(prod_val))
+        at_buf[i, t]    <<- att_buf[i, t-1] + model$count[i, t-1]
+        prod_val <- 0
+        for(k in 1:dbeta) {
+          prod_val <- prod_val + model$x[i, t-1, k] * model$beta[k]
+        }
+        bt_buf[i, t] <<- w*bt_buf[i, t-1] +
+          model$epsilon[i] * model$E[i, t-1] * exp(prod_val)
       }
-    }
-    
-    # Smoothing (unchanged but use <-)
-    lambda_aux <- matrix(0, n_regions, n_times)
-    lambda_smooth <- matrix(0, n_regions, n_times)
-    lambda_smooth[, n_times] <- lambda[, n_times]
-    for (j in 1:(n_times - 1)) {
-      for (r in 1:n_regions) {
-        lambda_aux[r, n_times - j] <- rgamma(1, shape = (1 - w) * a[r, n_times - j], scale = 1 / b[r, n_times - j])
-        lambda_smooth[r, n_times - j] <- lambda_aux[r, n_times - j] + w * lambda_smooth[r, n_times - j + 1]
+      model$lambda[i, n_times] <<-
+        rgamma(1, at_buf[i, n_times], btt_buf[i, n_times])
+      for(tt in n_times:2) {
+        model$lambda[i, tt-1] <<-
+          rgamma(1,
+                 (1 - w) * at_buf[i, tt-1],
+                 bt_buf[i, tt-1]
+          ) + w * model$lambda[i, tt]
       }
     }
-    
-    # Update model (only place <<- is needed)
-    for (r in 1:n_regions) {
-      model$lambda[r, ] <<- lambda_smooth[r, ]
-    }
-    copy(from = model, to = mvSaved, row = 1, nodes = target, logProb = TRUE)
+    model$calculate(calcNodes)
+    copy(from = model, to = mvSaved, row = 1,
+         nodes = calcNodes, logProb = TRUE)
   },
-  methods = list(reset = function() {})
+  methods = list(
+    reset = function() {}
+  )
 )
